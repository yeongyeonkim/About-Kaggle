# NumPy 특징

수치 데이터를 다루는데 효율적이고 높은 성능을 제공 한다.

* 대규모 데이터를 빠르게

# ndarray

* NumPy의 핵심.
* ndarray : n-dimensional array object, 다차원 배열 객체
* 모든 요소가 동일한 dayatype (기본은 float64)
* 다차원 데이터도 연속 할당: 높은 성능의 비밀 (파이썬 리스트는 비연속)

# NumPy 성능

* NumPy와 Pandas를 사용하면, 반복문을 거의 사용하지 않고도 데이터 처리
* 코드가 줄어들 뿐만 아니라, 성능도 최대 수 백배까지 빠르다.

<pre><code>import numpy as np
ls = range(1000)
%timeit [i**2 for i in ls]
a = np.arange(1000)
%timeit a**2
</code></pre>

# 마이너스 인덱스

ar = np.arrange(0,16).reshape((4,4))

print(ar)

[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]

---

print(ar[-2])

[ 8  9 10 11]

---

print(ar[-2:])

[ 8  9 10 11]
 [12 13 14 15]

---

print(ar[:-2])

[ 0  1  2  3]
[ 4  5  6  7]


# 슬라이싱

print(ar) 

[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
 
 ---
 
 ar[2, : 2] = 99 # 값 바꾸기
 print(ar)
 
 [[ 0  1  2  3]
 [ 4  5  6  7]
 [99 99 10 11]
 [12 13 14 15]]
 
# View & Copy
### 슬라이싱의 결과는 뷰(view)이다. 뷰를 통해 수정하면 원본 데이터가 수정된다.

ar = np.array([[10,20,30],[60,70,80],[90,91,92]])
v = ar[1]
v[:] = 50 # v 배열 전체 요소에 20을 할당 # v는 ar의 뷰, v의 값을 변경하는 것은 ar의 값을 변경.
print(ar)

[[10 20 30]
 [50 50 50]
 [90 91 92]]
 
##### ar과 v를 완전히 다른 객체로 만드려면 copy를 사용

v = ar[1].copy()
v[:] = 50
print(ar)
[[10 20 30]
 [60 70 80]
 [90 91 92]]
 
 
# 팬시 인덱싱 (fancy indexing)

<pre><code>
ar = np.array([[0], [10], [20], [30], [40], [50]]) + np.array([[0, 1, 2, 3, 4, 5]])
ar

print(ar[[0,2,-1]]) # 지정한 row 얻기
print(ar[:, [0,2,-1]]) # 지정한 column 얻기

out[]:

[[ 0  1  2  3  4  5]
 [20 21 22 23 24 25]
 [50 51 52 53 54 55]]

[[ 0  2  5]
 [10 12 15]
 [20 22 25]
 [30 32 35]
 [40 42 45]
 [50 52 55]]
 
</code></pre>


